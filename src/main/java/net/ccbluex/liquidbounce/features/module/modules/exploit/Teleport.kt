/*
 * FDPClient Hacked Client
 * A free open source mixin-based injection hacked client for Minecraft using Minecraft Forge by LiquidBounce.
 * https://github.com/SkidderMC/FDPClient/
 */
package net.ccbluex.liquidbounce.features.module.modules.exploit

import net.ccbluex.liquidbounce.event.*
import net.ccbluex.liquidbounce.features.module.Module
import net.ccbluex.liquidbounce.features.module.ModuleCategory
import net.ccbluex.liquidbounce.features.module.ModuleInfo
import net.ccbluex.liquidbounce.features.value.BoolValue
import net.ccbluex.liquidbounce.features.value.ListValue
import net.ccbluex.liquidbounce.utils.MovementUtils.forward
import net.ccbluex.liquidbounce.utils.MovementUtils.strafe
import net.ccbluex.liquidbounce.utils.PathUtils
import net.ccbluex.liquidbounce.utils.block.BlockUtils.getBlock
import net.ccbluex.liquidbounce.utils.render.RenderUtils
import net.ccbluex.liquidbounce.utils.timer.TickTimer
import net.minecraft.block.BlockAir
import net.minecraft.block.BlockFence
import net.minecraft.block.BlockSnow
import net.minecraft.block.material.Material
import net.minecraft.client.renderer.GlStateManager
import net.minecraft.network.Packet
import net.minecraft.network.play.client.C03PacketPlayer
import net.minecraft.network.play.client.C03PacketPlayer.C04PacketPlayerPosition
import net.minecraft.network.play.client.C03PacketPlayer.C06PacketPlayerPosLook
import net.minecraft.network.play.client.C0BPacketEntityAction
import net.minecraft.util.AxisAlignedBB
import net.minecraft.util.BlockPos
import net.minecraft.util.MovingObjectPosition
import net.minecraft.util.Vec3
import org.lwjgl.input.Mouse
import org.lwjgl.opengl.GL11
import java.awt.Color
import java.util.*
import java.util.function.Consumer

@ModuleInfo(name = "Teleport", category = ModuleCategory.EXPLOIT)
class Teleport : Module() {
    private val ignoreNoCollision = BoolValue("IgnoreNoCollision", true)
    private val modeValue = ListValue(
        "Mode",
        arrayOf("Tp", "Blink", "Flag", "Rewinside", "OldRewinside", "Spoof", "Minesucht", "AAC3.5.0", "BWRel", "Karhu"),
        "Tp"
    )
    private val buttonValue = ListValue("Button", arrayOf("Left", "Right", "Middle"), "Middle")
    private val needSneak = BoolValue("NeedSneak", true)
    private val flyTimer = TickTimer()
    private var hadGround = false
    private var fixedY = 0.0
    private val packets: MutableList<Packet<*>> = ArrayList()
    private var disableLogger = false
    private var zitter = false
    private var doTeleport = false
    private var freeze = false
    private val freezeTimer = TickTimer()
    private val respawnTimer = TickTimer()

    private var delay = 0
    private var endPos: BlockPos? = null
    private var objectPosition: MovingObjectPosition? = null

    private var endX = 0.0
    private var endY = 0.0
    private var endZ = 0.0

    override fun onEnable() {
        val matrixStage = -1

        if (modeValue.equals("AAC3.5.0")) {
            alert("§c>>> §a§lTeleport §fAAC 3.5.0 §c<<<")
            alert("§cHow to teleport: §aPress " + buttonValue.get() + " mouse button.")
            alert("§cHow to cancel teleport: §aDisable teleport module.")
        }
    }

    override fun onDisable() {
        fixedY = 0.0
        delay = 0
        mc.timer.timerSpeed = 1f
        endPos = null
        hadGround = false
        freeze = false
        disableLogger = false
        flyTimer.reset()

        packets.clear()
    }

    @EventTarget
    fun onUpdate(event: UpdateEvent?) {
        val buttonIndex = listOf(*buttonValue.values).indexOf(buttonValue.get())

        if (modeValue.equals("AAC3.5.0")) {
            freezeTimer.update()

            if (freeze && freezeTimer.hasTimePassed(40)) {
                freezeTimer.reset()
                freeze = false
                state = false
            }

            if (!flyTimer.hasTimePassed(60)) {
                flyTimer.update()

                if (mc.thePlayer.onGround) {
                    mc.thePlayer.jump()
                } else {
                    forward(if (zitter) -0.21 else 0.21)
                    zitter = !zitter
                }

                hadGround = false
                return
            }

            if (mc.thePlayer.onGround) hadGround = true

            if (!hadGround) return

            if (mc.thePlayer.onGround) mc.thePlayer.setPositionAndUpdate(
                mc.thePlayer.posX,
                mc.thePlayer.posY + 0.2,
                mc.thePlayer.posZ
            )

            val vanillaSpeed = 2f
            mc.thePlayer.capabilities.isFlying = false
            mc.thePlayer.motionY = 0.0
            mc.thePlayer.motionX = 0.0
            mc.thePlayer.motionZ = 0.0
            if (mc.gameSettings.keyBindJump.isKeyDown) mc.thePlayer.motionY += vanillaSpeed.toDouble()
            if (mc.gameSettings.keyBindSneak.isKeyDown) mc.thePlayer.motionY -= vanillaSpeed.toDouble()
            strafe(vanillaSpeed)

            if (Mouse.isButtonDown(buttonIndex) && !doTeleport) {
                mc.thePlayer.setPositionAndUpdate(mc.thePlayer.posX, mc.thePlayer.posY - 11, mc.thePlayer.posZ)

                disableLogger = true
                packets.forEach(Consumer { packet: Packet<*>? -> mc.netHandler.addToSendQueue(packet) })

                freezeTimer.reset()
                freeze = true
            }

            doTeleport = Mouse.isButtonDown(buttonIndex)
            return
        }


        if (mc.currentScreen == null && Mouse.isButtonDown(buttonIndex) && delay <= 0) {
            endPos = objectPosition!!.blockPos


            if (Objects.requireNonNull(getBlock(endPos))!!.material === Material.air) {
                endPos = null
                return
            }

            alert(
                "§7[§8§lTeleport§7] §3Position was set to §8" + endPos!!.x + "§3, §8" + ((if (Objects.requireNonNull(
                        getBlock(
                            objectPosition!!.blockPos
                        )
                    )!!.getCollisionBoundingBox(
                        mc.theWorld, objectPosition!!.blockPos, Objects.requireNonNull(
                            getBlock(
                                objectPosition!!.blockPos
                            )
                        )!!.defaultState
                    ) == null
                ) endPos!!.y + Objects.requireNonNull(getBlock(endPos))!!.blockBoundsMaxY else Objects.requireNonNull(
                    getBlock(
                        objectPosition!!.blockPos
                    )
                )?.getCollisionBoundingBox(
                    mc.theWorld, objectPosition!!.blockPos, Objects.requireNonNull(
                        getBlock(
                            objectPosition!!.blockPos
                        )
                    )!!.defaultState
                )!!.maxY) + fixedY) + "§3, §8" + endPos!!.z
            )
            delay = 6
            endX = endPos!!.x.toDouble() + 0.5
            endY = endPos!!.y.toDouble() + 1.0
            endZ = endPos!!.z.toDouble() + 0.5
        }

        if (delay > 0) --delay

        if (endPos != null) {
            when (modeValue.get().lowercase(Locale.getDefault())) {
                "blink" -> if (mc.thePlayer.isSneaking || !needSneak.get()) {
                    // Sneak
                    mc.netHandler.addToSendQueue(
                        C0BPacketEntityAction(
                            mc.thePlayer,
                            C0BPacketEntityAction.Action.STOP_SNEAKING
                        )
                    )

                    // Teleport
                    PathUtils.findBlinkPath(endX, endY, endZ).forEach(Consumer { vector3d: Vec3 ->
                        mc.netHandler.addToSendQueue(
                            C04PacketPlayerPosition(
                                vector3d.xCoord,
                                vector3d.yCoord,
                                vector3d.zCoord,
                                true
                            )
                        )
                        mc.thePlayer.setPosition(endX, endY, endZ)
                    })

                    // Sneak
                    mc.netHandler.addToSendQueue(
                        C0BPacketEntityAction(
                            mc.thePlayer,
                            C0BPacketEntityAction.Action.START_SNEAKING
                        )
                    )

                    // Notify
                    alert("§7[§8§lTeleport§7] §3You were teleported to §8$endX§3, §8$endY§3, §8$endZ")
                    endPos = null
                }

                "flag" -> if (mc.thePlayer.isSneaking || !needSneak.get()) {
                    // Sneak
                    mc.netHandler.addToSendQueue(
                        C0BPacketEntityAction(
                            mc.thePlayer,
                            C0BPacketEntityAction.Action.STOP_SNEAKING
                        )
                    )

                    // Teleport
                    mc.netHandler.addToSendQueue(
                        C04PacketPlayerPosition(
                            mc.thePlayer.posX,
                            mc.thePlayer.posY,
                            mc.thePlayer.posZ,
                            true
                        )
                    )
                    mc.netHandler.addToSendQueue(C04PacketPlayerPosition(endX, endY, endZ, true))
                    mc.netHandler.addToSendQueue(
                        C04PacketPlayerPosition(
                            mc.thePlayer.posX,
                            mc.thePlayer.posY,
                            mc.thePlayer.posZ,
                            true
                        )
                    )
                    mc.netHandler.addToSendQueue(
                        C04PacketPlayerPosition(
                            mc.thePlayer.posX,
                            mc.thePlayer.posY + 5.0,
                            mc.thePlayer.posZ,
                            true
                        )
                    )
                    mc.netHandler.addToSendQueue(C04PacketPlayerPosition(endX, endY, endZ, true))
                    mc.netHandler.addToSendQueue(
                        C04PacketPlayerPosition(
                            mc.thePlayer.posX + 0.5,
                            mc.thePlayer.posY,
                            mc.thePlayer.posZ + 0.5,
                            true
                        )
                    )

                    forward(0.04)

                    // Sneak
                    mc.netHandler.addToSendQueue(
                        C0BPacketEntityAction(
                            mc.thePlayer,
                            C0BPacketEntityAction.Action.START_SNEAKING
                        )
                    )
                    // Notify
                    alert("§7[§8§lTeleport§7] §3You were teleported to §8$endX§3, §8$endY§3, §8$endZ")
                    endPos = null
                }

                "bwrel" -> if (mc.thePlayer.isSneaking || !needSneak.get()) {
                    mc.thePlayer.setPosition(
                        mc.thePlayer.posX,
                        mc.thePlayer.posY + 9.25078381072525,
                        mc.thePlayer.posZ
                    )
                    mc.thePlayer.motionY = 1.0420262142255328
                    mc.netHandler.addToSendQueue(C04PacketPlayerPosition(endX, endY, endZ, true))
                }

                "rewinside" -> {
                    mc.thePlayer.motionY = 0.1
                    mc.netHandler.addToSendQueue(C04PacketPlayerPosition(endX, endY, endZ, true))
                    mc.netHandler.addToSendQueue(
                        C04PacketPlayerPosition(
                            mc.thePlayer.posX,
                            mc.thePlayer.posY + 0.6,
                            mc.thePlayer.posZ,
                            true
                        )
                    )

                    if (mc.thePlayer.posX.toInt().toDouble() == endX && mc.thePlayer.posY.toInt()
                            .toDouble() == endY && mc.thePlayer.posZ.toInt().toDouble() == endZ
                    ) {
                        alert("§7[§8§lTeleport§7] §3You were teleported to §8$endX§3, §8$endY§3, §8$endZ")
                        endPos = null
                    } else alert("§7[§8§lTeleport§7] §3Teleport try...")
                }

                "oldrewinside" -> {
                    mc.thePlayer.motionY = 0.1

                    mc.netHandler.addToSendQueue(
                        C04PacketPlayerPosition(
                            mc.thePlayer.posX,
                            mc.thePlayer.posY,
                            mc.thePlayer.posZ,
                            true
                        )
                    )
                    mc.netHandler.addToSendQueue(C04PacketPlayerPosition(endX, endY, endZ, true))
                    mc.netHandler.addToSendQueue(
                        C04PacketPlayerPosition(
                            mc.thePlayer.posX,
                            mc.thePlayer.posY,
                            mc.thePlayer.posZ,
                            true
                        )
                    )
                    mc.netHandler.addToSendQueue(
                        C04PacketPlayerPosition(
                            mc.thePlayer.posX,
                            mc.thePlayer.posY,
                            mc.thePlayer.posZ,
                            true
                        )
                    )
                    mc.netHandler.addToSendQueue(C04PacketPlayerPosition(endX, endY, endZ, true))
                    mc.netHandler.addToSendQueue(
                        C04PacketPlayerPosition(
                            mc.thePlayer.posX,
                            mc.thePlayer.posY,
                            mc.thePlayer.posZ,
                            true
                        )
                    )

                    if (mc.thePlayer.posX.toInt().toDouble() == endX && mc.thePlayer.posY.toInt()
                            .toDouble() == endY && mc.thePlayer.posZ.toInt().toDouble() == endZ
                    ) {
                        alert("§7[§8§lTeleport§7] §3You were teleported to §8$endX§3, §8$endY§3, §8$endZ")
                        endPos = null
                    } else alert("§7[§8§lTeleport§7] §3Teleport try...")

                    forward(0.04)
                }

                "minesucht" -> {
                    if (!mc.thePlayer.isSneaking && needSneak.get())

                        mc.netHandler.addToSendQueue(C04PacketPlayerPosition(endX, endY, endZ, true))
                    alert("§7[§8§lTeleport§7] §3You were teleported to §8$endX§3, §8$endY§3, §8$endZ")
                    endPos = null
                }

                "tp" -> {
                    if (!mc.thePlayer.isSneaking && needSneak.get())

                        mc.netHandler.addToSendQueue(C04PacketPlayerPosition(endX, endY, endZ, true))
                    mc.thePlayer.setPosition(endX, endY, endZ)
                    alert("§7[§8§lTeleport§7] §3You were teleported to §8$endX§3, §8$endY§3, §8$endZ")
                    endPos = null
                }

                "karhu" -> {
                    if (!mc.thePlayer.isSneaking && needSneak.get())

                        mc.netHandler.addToSendQueue(C04PacketPlayerPosition(endX, endY, endZ, false))
                    mc.netHandler.addToSendQueue(
                        C04PacketPlayerPosition(
                            mc.thePlayer.posX,
                            mc.thePlayer.posY,
                            mc.thePlayer.posZ,
                            false
                        )
                    )
                    mc.netHandler.addToSendQueue(C04PacketPlayerPosition(endX, endY, endZ, false))
                    mc.netHandler.addToSendQueue(
                        C04PacketPlayerPosition(
                            mc.thePlayer.posX,
                            mc.thePlayer.posY,
                            mc.thePlayer.posZ,
                            false
                        )
                    )
                    mc.netHandler.addToSendQueue(C04PacketPlayerPosition(endX, endY, endZ, false))
                    mc.netHandler.addToSendQueue(
                        C04PacketPlayerPosition(
                            mc.thePlayer.posX,
                            mc.thePlayer.posY,
                            mc.thePlayer.posZ,
                            false
                        )
                    )
                    mc.netHandler.addToSendQueue(C04PacketPlayerPosition(endX, endY, endZ, false))
                    mc.netHandler.addToSendQueue(
                        C04PacketPlayerPosition(
                            mc.thePlayer.posX,
                            mc.thePlayer.posY,
                            mc.thePlayer.posZ,
                            false
                        )
                    )
                    mc.netHandler.addToSendQueue(C04PacketPlayerPosition(endX, endY, endZ, false))
                    mc.netHandler.addToSendQueue(
                        C04PacketPlayerPosition(
                            mc.thePlayer.posX,
                            mc.thePlayer.posY,
                            mc.thePlayer.posZ,
                            false
                        )
                    )
                    mc.thePlayer.setPosition(endX, endY, endZ)

                    alert("§7[§8§lTeleport§7] §3You were teleported to §8$endX§3, §8$endY§3, §8$endZ")
                    endPos = null
                }
            }
        }
    }

    @EventTarget
    fun onRender3D(event: Render3DEvent?) {
        if (modeValue.equals("AAC3.5.0")) return

        val lookVec = Vec3(
            mc.thePlayer.lookVec.xCoord * 300,
            mc.thePlayer.lookVec.yCoord * 300,
            mc.thePlayer.lookVec.zCoord * 300
        )
        val posVec = Vec3(mc.thePlayer.posX, mc.thePlayer.posY + 1.62, mc.thePlayer.posZ)

        objectPosition =
            mc.thePlayer.worldObj.rayTraceBlocks(posVec, posVec.add(lookVec), false, ignoreNoCollision.get(), false)

        if (objectPosition == null || objectPosition!!.blockPos == null) return

        val belowBlockPos =
            BlockPos(objectPosition!!.blockPos.x, objectPosition!!.blockPos.y - 1, objectPosition!!.blockPos.z)

        fixedY = if (getBlock(objectPosition!!.blockPos) is BlockFence) (if (mc.theWorld.getCollidingBoundingBoxes(
                mc.thePlayer, mc.thePlayer.entityBoundingBox.offset(
                    objectPosition!!.blockPos.x + 0.5 - mc.thePlayer.posX,
                    objectPosition!!.blockPos.y + 1.5 - mc.thePlayer.posY,
                    objectPosition!!.blockPos.z + 0.5 - mc.thePlayer.posZ
                )
            ).isEmpty()
        ) 0.5 else 0.0) else if (getBlock(belowBlockPos) is BlockFence) (if (mc.theWorld.getCollidingBoundingBoxes(
                mc.thePlayer, mc.thePlayer.entityBoundingBox.offset(
                    objectPosition!!.blockPos.x + 0.5 - mc.thePlayer.posX,
                    objectPosition!!.blockPos.y + 0.5 - mc.thePlayer.posY,
                    objectPosition!!.blockPos.z + 0.5 - mc.thePlayer.posZ
                )
            ).isNotEmpty() || Objects.requireNonNull(
                getBlock(
                    objectPosition!!.blockPos
                )
            )!!.getCollisionBoundingBox(
                mc.theWorld, objectPosition!!.blockPos, Objects.requireNonNull(
                    getBlock(
                        objectPosition!!.blockPos
                    )
                )!!.defaultState
            ) == null
        ) 0.0 else 0.5 - Objects.requireNonNull(
            getBlock(
                objectPosition!!.blockPos
            )
        )!!.blockBoundsMaxY) else if (getBlock(objectPosition!!.blockPos) is BlockSnow) Objects.requireNonNull(
            getBlock(
                objectPosition!!.blockPos
            )
        )!!.blockBoundsMaxY - 0.125 else 0.0

        val x = objectPosition!!.blockPos.x
        val y = (if (Objects.requireNonNull(
                getBlock(
                    objectPosition!!.blockPos
                )
            )!!.getCollisionBoundingBox(
                mc.theWorld, objectPosition!!.blockPos, Objects.requireNonNull(
                    getBlock(
                        objectPosition!!.blockPos
                    )
                )!!.defaultState
            ) == null
        ) objectPosition!!.blockPos.y + Objects.requireNonNull(
            getBlock(
                objectPosition!!.blockPos
            )
        )!!.blockBoundsMaxY else Objects.requireNonNull(
            getBlock(
                objectPosition!!.blockPos
            )
        )?.getCollisionBoundingBox(
            mc.theWorld, objectPosition!!.blockPos, Objects.requireNonNull(
                getBlock(
                    objectPosition!!.blockPos
                )
            )!!.defaultState
        )!!.maxY) - 1.0 + fixedY
        val z = objectPosition!!.blockPos.z

        if (getBlock(objectPosition!!.blockPos) !is BlockAir) {
            val renderManager = mc.renderManager

            GL11.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA)
            GL11.glEnable(GL11.GL_BLEND)
            GL11.glLineWidth(2f)
            GL11.glDisable(GL11.GL_TEXTURE_2D)
            GL11.glDisable(GL11.GL_DEPTH_TEST)
            GL11.glDepthMask(false)
            RenderUtils.glColor(
                if (modeValue.equals("minesucht") && mc.thePlayer.position.y.toDouble() != y + 1) Color(
                    255,
                    0,
                    0,
                    90
                ) else if (mc.theWorld.getCollidingBoundingBoxes(
                        mc.thePlayer,
                        mc.thePlayer.entityBoundingBox.offset(
                            x + 0.5 - mc.thePlayer.posX,
                            y + 1.0 - mc.thePlayer.posY,
                            z + 0.5 - mc.thePlayer.posZ
                        )
                    ).isNotEmpty()
                ) Color(255, 0, 0, 90) else Color(0, 255, 0, 90)
            )
            RenderUtils.drawFilledBox(
                AxisAlignedBB(
                    x - renderManager.renderPosX,
                    (y + 1) - renderManager.renderPosY,
                    z - renderManager.renderPosZ,
                    x - renderManager.renderPosX + 1.0,
                    y + 1.2 - renderManager.renderPosY,
                    z - renderManager.renderPosZ + 1.0
                )
            )
            GL11.glEnable(GL11.GL_TEXTURE_2D)
            GL11.glEnable(GL11.GL_DEPTH_TEST)
            GL11.glDepthMask(true)
            GL11.glDisable(GL11.GL_BLEND)

            RenderUtils.renderNameTag(
                Math.round(mc.thePlayer.getDistance(x + 0.5, y + 1.0, z + 0.5)).toString() + "m",
                x + 0.5,
                y + 1.7,
                z + 0.5
            )
            GlStateManager.resetColor()
        }
    }

    @EventTarget
    fun onMove(event: MoveEvent) {
        if (modeValue.equals("aac3.5.0") && freeze) {
            event.zeroXZ()
        }
    }

    @EventTarget
    fun onPacket(event: PacketEvent) {
        val packet = event.packet

        if (disableLogger) return

        if (packet is C03PacketPlayer) {

            when (modeValue.get().lowercase(Locale.getDefault())) {
                "spoof" -> {
                    if (endPos == null)
                        packet.x = endPos!!.x + 0.5
                    packet.y = (endPos!!.y + 1).toDouble()
                    packet.z = endPos!!.z + 0.5
                    mc.thePlayer.setPosition(endPos!!.x + 0.5, (endPos!!.y + 1).toDouble(), endPos!!.z + 0.5)
                }

                "aac3.5.0" -> {
                    if (!flyTimer.hasTimePassed(60)) return

                    event.cancelEvent()

                    if (packet !is C04PacketPlayerPosition && packet !is C06PacketPlayerPosLook) return

                    packets.add(packet)
                }
            }
        }
    }

    override val tag: String
        get() = modeValue.get()
}

