/*
 * FDPClient Hacked Client
 * A free open source mixin-based injection hacked client for Minecraft using Minecraft Forge by LiquidBounce.
 * https://github.com/SkidderMC/FDPClient/
 */
package net.ccbluex.liquidbounce.features.module.modules.exploit.disablers.verus

import net.ccbluex.liquidbounce.event.EventTarget
import net.ccbluex.liquidbounce.event.MoveEvent
import net.ccbluex.liquidbounce.event.PacketEvent
import net.ccbluex.liquidbounce.event.WorldEvent
import net.ccbluex.liquidbounce.features.module.modules.exploit.disablers.DisablerMode
import net.ccbluex.liquidbounce.features.value.BoolValue
import net.ccbluex.liquidbounce.utils.PacketUtils.sendPacketNoEvent
import net.minecraft.network.Packet
import net.minecraft.network.play.client.C03PacketPlayer.C04PacketPlayerPosition
import net.minecraft.network.play.client.C0BPacketEntityAction
import java.util.concurrent.ConcurrentLinkedQueue

class OldVerusCustomDisabler : DisablerMode("OldVerusCustomDisabler") {
    private val movementDisabler = BoolValue("Movement", false)
    private val sprintDisabler = BoolValue("Sprint", false)

    private val transactions = ConcurrentLinkedQueue<Packet<*>>()
    private val keepAlives = ConcurrentLinkedQueue<Packet<*>>()

    private var teleported = false

    @EventTarget
    override fun onMove(event: MoveEvent) {
        if (movementDisabler.value) {
            if (mc.thePlayer.ticksExisted % 100 == 0) {
                sendPacketNoEvent(
                    C04PacketPlayerPosition(
                        mc.thePlayer.posX,
                        mc.thePlayer.posY,
                        mc.thePlayer.posZ,
                        mc.thePlayer.onGround
                    )
                )
                sendPacketNoEvent(C04PacketPlayerPosition(mc.thePlayer.posX, -0.015625, mc.thePlayer.posZ, false))
                sendPacketNoEvent(
                    C04PacketPlayerPosition(
                        mc.thePlayer.posX,
                        mc.thePlayer.posY,
                        mc.thePlayer.posZ,
                        mc.thePlayer.onGround
                    )
                )

                teleported = true
            }
        }

        if (sprintDisabler.value) {
            sendPacketNoEvent(
                C0BPacketEntityAction(
                    mc.thePlayer,
                    if (mc.thePlayer.ticksExisted % 2 == 0) C0BPacketEntityAction.Action.STOP_SPRINTING else C0BPacketEntityAction.Action.START_SPRINTING
                )
            )
        }
    }

    @EventTarget
    override fun onPacket(event: PacketEvent) {
        val packet = event.packet

        if (sprintDisabler.value && packet is C0BPacketEntityAction) {

            if (packet.action == C0BPacketEntityAction.Action.START_SPRINTING ||
                packet.action == C0BPacketEntityAction.Action.STOP_SPRINTING
            ) {
                event.cancelEvent()
            }
        }
    }

    @EventTarget
    fun onWorld(event: MoveEvent) {
        if (movementDisabler.value) {
            if (teleported) {
                event.cancelEvent()
            }

            teleported = false
        }
    }

    override fun onWorld(event: WorldEvent) {
        transactions.clear()
        keepAlives.clear()
        teleported = false
    }
}