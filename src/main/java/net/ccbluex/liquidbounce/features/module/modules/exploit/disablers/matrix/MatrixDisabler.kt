/*
 * FDPClient Hacked Client
 * A free open source mixin-based injection hacked client for Minecraft using Minecraft Forge by LiquidBounce.
 * https://github.com/SkidderMC/FDPClient/
 */
package net.ccbluex.liquidbounce.features.module.modules.exploit.disablers.matrix

import net.ccbluex.liquidbounce.FDPClient
import net.ccbluex.liquidbounce.event.PacketEvent
import net.ccbluex.liquidbounce.event.PostMotionEvent
import net.ccbluex.liquidbounce.features.module.modules.exploit.disablers.DisablerMode
import net.ccbluex.liquidbounce.features.module.modules.movement.Flight
import net.ccbluex.liquidbounce.features.module.modules.movement.Speed
import net.ccbluex.liquidbounce.features.value.BoolValue
import net.ccbluex.liquidbounce.utils.ClientUtils.displayChatMessage
import net.ccbluex.liquidbounce.utils.MovementUtils.isMoving
import net.ccbluex.liquidbounce.utils.PacketUtils
import net.ccbluex.liquidbounce.utils.RotationUtils
import net.minecraft.network.play.client.C03PacketPlayer
import net.minecraft.network.play.client.C03PacketPlayer.C06PacketPlayerPosLook
import net.minecraft.network.play.client.C08PacketPlayerBlockPlacement
import net.minecraft.network.play.client.C09PacketHeldItemChange
import net.minecraft.util.BlockPos

class MatrixDisabler : DisablerMode("Matrix") {

	private val matrixNoCheck = BoolValue("NoModuleCheck", false)
	private val matrixMoveFix = BoolValue("MoveFix", true)
	private val matrixMoveOnly = BoolValue("MoveOnly", false)
	private val matrixNoMovePacket = BoolValue("NoMovePacket", true)
	private val matrixHotbarChange = BoolValue("HotbarChange", true)

	override fun onPacket(event: PacketEvent) {
		val packet = event.packet
		if (matrixNoCheck.get() || FDPClient.moduleManager.getModule(Speed::class.java)!!.state || FDPClient.moduleManager.getModule(Flight::class.java)!!.state) {
			if (packet is C03PacketPlayer) {
                if (matrixNoMovePacket.get() && !packet.isMoving) {
					event.cancelEvent()
					displayChatMessage("no move, cancelled")
					return
				}
				if (matrixMoveFix.get()) {
					packet.onGround = true
					if (!packet.rotating) {
						packet.rotating = true
						packet.yaw = mc.thePlayer.rotationYaw
						packet.pitch = mc.thePlayer.rotationPitch
					}
				}
			}
		}
	}
	
	@Override
	fun onPostMotion(event: PostMotionEvent) {
		if (!matrixMoveOnly.get() || isMoving())
			if (matrixNoCheck.get() || FDPClient.moduleManager[Flight::class.java]!!.state || FDPClient.moduleManager[Speed::class.java]!!.state) {
				var changed = false
				if (matrixHotbarChange.get()) for (i in 0..8) {
                    // find an empty inventory slot
        			if(mc.thePlayer.inventory.mainInventory[i] == null && i != mc.thePlayer.inventory.currentItem) {
            			PacketUtils.sendPacketNoEvent(C09PacketHeldItemChange(i))
						changed = true
						displayChatMessage("found empty slot $i, switching")
            			break
        			}
				}

				RotationUtils.serverRotation?.let { C06PacketPlayerPosLook(mc.thePlayer.posX, mc.thePlayer.posY, mc.thePlayer.posZ, it.yaw, RotationUtils.serverRotation!!.pitch, mc.thePlayer.onGround) }
					?.let { PacketUtils.sendPacketNoEvent(it) }
				mc.netHandler.addToSendQueue(C08PacketPlayerBlockPlacement(BlockPos(-1, -1, -1), -1, null, 0f, 0f, 0f))
				displayChatMessage("sent placement")

				if (changed) {
					PacketUtils.sendPacketNoEvent(C09PacketHeldItemChange(mc.thePlayer.inventory.currentItem))
					displayChatMessage("switched back")
				}
			}
	}

}